-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"
require "socket-helpers"
require "copas"

class("Server", "common.Object")


-- constructor fields: 
-- name: name of game, for server browsers
-- host: interface to bind to
-- port: port to bind to
-- pass: game password. Optional.
-- admin: port for admin console. Always binds to localhost. Optional.
-- load: saved game to load on startup. Optional.
local _init = __init
function __init(self, t)
	_init(self, t)
	self.sendq = {}
	self.players = {}
	self.id = "S"
end

function start(self)
	-- if these aren't set, it's a programming error
	assert(self.port and self.host and self.name, "Invalid arguments to constructor for server.Server")
	assert(not self.game, "Server is already running")

    local err
    self.socket,err = socket.bind(self.host, self.port)
    
    if not self.socket then
        return nil,err
    end
    
    copas.addserver(self.socket, function(...) return self:receiver(...) end)
    self.game = new "Game" {}
    self:message("server listening on port %d", self.port)
    
    return true
end

-- cleanly shut down the server. FIXME: no implemented
function stop(self)
    assert(self.game, "server is not running")
    error "not implemented"
end

-- server message function, prefixes messages with [server]
function message(self, fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

-- each instance of this function is responsible for handling a single client.
-- Whenever a client connects, copas will automatically create a new thread
-- from this function; when it returns, the socket is closed.
-- Note that neither this function, nor anything called by it, should EVER
-- send data (or perform additional socket reads); doing so may permit the
-- thread to block halfway through an operation on shared state and awaken
-- another thread.
-- Instead, use the server's :sendTo and :broadcast methods, which will
-- insert the messages into a queue which is periodically emptied by another
-- thread.
function receiver(self, sock)
    new "Client" {
        socket = sock;
        server = self;
    }:run()
end

function sendTo(self, player, ...)
    local msg = table.pack(...)
    msg.target = player
    table.insert(self.sendq, msg)
end

function broadcast(self, ...)
    table.insert(self.sendq, table.pack(...))
end

function sendQueuedMessages(self)
    for i,msg in ipairs(self.sendq) do
        if msg.target then
            msg.target:sendmsg(table.unpack(msg))
        else
            -- send message to all connected players
            for _,player in ipairs(self.players) do
                player:sendmsg(table.unpack(msg))
            end
        end
        self.sendq[i] = nil
    end
end

-- mainloop function for the server. The UI is expected to call this frequently
-- (say, 5-30 times a second) to collect network traffic and process pending
-- events.
function update(self, timeout)
    copas.step(timeout)
    self:sendQueuedMessages()
    return true
end

function login(self, socket, info)
    if not type(info) == "table" or not info.name then
        return false,"malformed login request"
    
    elseif self.pass and (self.pass ~= info.pass) then
        return false,"incorrect password"
        
    elseif self.players[info.name] then
        return false,"name collision with existing player"
    end
    
    self:addPlayer(socket, info.name, info.colour)
    self:message("%s joined the game.", info.name)
    
    return true
end

function logout(self, name)
    self.players[name] = nil
    self:message("%s left the game.", name)
end

function addPlayer(self, socket, name, colour)
    local p = new "Player" {
        name = name;
        colour = colour;
        socket = socket;
    }
    
    self.players[p.name] = p
    -- FIXME add player object to the game as well
end
