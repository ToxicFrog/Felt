-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"

class(..., felt.Object)

updating = false -- true during a server update step; the automatic RMI dispatcher
-- needs to be able to tell whether it's executing in a server or client ctx

local _init = __init
function __init(self, t)
	_init(self, t)
	self.events = {}
	self.id = "S"
end

-- server message function, prefixes messages with [server]
function message(self, fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

-- mainloop tick function, called every frame by main
function update(self)
	if not self.socket then return end
	
	self.updating = true
	local i = 1
	local events = self.events
	
	-- TODO: collect events from network sockets
	self:tryAccept()
	
	self:collectMessages()
	
	while events[i] do
		self:dispatch(events[i])
		i = i+1
	end
	
	self.events = {}
	self.updating = false
end

function tryAccept(self)
	local sock = self.socket:accept()
	if sock then
		self:message("Connection accepted from %s", sock:getpeername())
	end
	table.insert(self.sockets, sock)
end

function collectMessages(self)
	local function object(id)
		if id == "S" then return self
		else return self.game:getObject(id)
		end
	end

	local function readmsg(sock)
		local buf = assert(recvmsg(sock))
		return new "Deserialization" { data = buf, object = object } :unpack(),data
	end
		
	local ready = socket.select(self.sockets, {}, 0)
	for i=1,#self.sockets do
		if ready[i] then
			local status,message,data = pcall(readmsg, ready[i])
			
			if not status then
				-- whoops, error reading from socket
				self:message("closing connection to %s (%s)", tostring(ready[i]:getpeername()), tostring(message))
				self.sockets[i]:close()
				local sock = table.remove(self.sockets, i)
				local name = self.players[sock]
				if name then
					self.players[name],self.players[sock] = nil,nil
				end
			else
				local sock = ready[i]
				message.raw = data
				message.sock = sock
				function message.reply(_, ...)
					self:send(sock, ...)
				end
				self:pushEvent(message)
			end
		end
	end
end

function pushEvent(self, evt)
	table.insert(self.events, evt)
end

function send(self, sock, ...)
	local buf = new "Serialization" { metamethod = "__send" }
		:pack(table.pack(...))
		:finalize()
	sendmsg(sock, buf)
end

function dispatch(self, evt)
	self.reply = evt.reply
	self.sender = evt.sock
	local obj = evt[1]
	local method = evt[2]
	
	assert(obj, "Malformed RMI: no object")
	assert(obj[method], "Malformed RMI: object "..tostring(obj).." has no method "..tostring(method)) 
	obj[method](obj, unpack(evt, 3))
	self.reply = nil
	self.sender = nil
end

function login(self, name, pass)
	self:message("Player connecting: %s", name)
	if self.pass ~= pass then
		self:message("Rejecting %s due to bad password.", name)
		self:message("my pass: '%s'", tostring(self.pass))
		self:message("their pass: '%s'", tostring(pass))
		self:reply(client, "disconnect", "Invalid password.")
		return
	end

	if self.players[name] then
		self:message("Rejecting %s due to name collision.", name)
		self:reply(client, "disconnect", "A player with the name '"..tostring(name).."' is already present in game.")
		return
	end
		
	-- HACK HACK HACK
	-- is it a local client?
	if client.name == name then
		self:reply(client, "setGame", self.game)
	else
		local sc = new "Serialization" { metamethod = "__save" }
		sc:pack(self.game)
		self:reply(client, "setGame", sc:finalize())
	end -- HACK HACK HACK

	self.players[name] = self.sender
	self.players[self.sender] = name
	
	-- we don't need to pass them a player object - if they're reconnecting,
	-- they'll claim the existing object, and if they're new, their first
	-- action will be to create a new player object
	
	self:message("Handshake with %s completed.", name)
	
	return
end

function broadcast(self, object, method, ...)
	object[method](object, ...)
	for _,socket in pairs(self.sockets) do
		if self.players[socket] then -- skip players who haven't logged in
			self:send(socket, object, method, ...)
		end
	end
end

-- public API to the server subsystem

function start(self, port, pass)
	self.players = {}
	self.sockets = {}
	self.port = port
	self.pass = pass
	
	local err
	self.socket,err = socket.bind("*", port)
	
	if not self.socket then
		ui.error("Unable to start server (networking error): "..err)
		return false
	end
	
	self.socket:settimeout(0)
	
	self.game = new "felt.Game" {}
	
	self:message("server listening on port %d", port)

	return true
end

function stop(self, reason)
	error("not implemented")
end
