-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"

class("Server", "Object")


-- constructor fields: 
-- name: name of game, for server browsers
-- host: interface to bind to
-- port: port to bind to
-- pass: game password. Optional.
-- admin: port for admin console. Always binds to localhost. Optional.
-- load: saved game to load on startup. Optional.
local _init = __init
function __init(self, t)
    _init(self, t)
    self.sockets = {} -- list of raw sockets for use with select
    self.clients = {} -- socket => client mapping
    self.players = {} -- name => client mapping
end

function start(self)
	-- if these aren't set, it's a programming error
	assert(self.port and self.host and self.name, "Invalid arguments to constructor for server.Server")
	assert(not self.game, "Server is already running")

    local err
    self.socket,err = socket.bind(self.host, self.port)
    
    if not self.socket then
        return nil,err
    end
    
    -- HACK HACK HACK - test code
    self.game = new "Game" { server = self }
    self.game:addField("test")
    self.game.fields.test:add(new "game.felt.Token" { name = "test object"; game = self.game; })
    
    self.socket:settimeout(0.1)
    self:message("Listening on port %d", self.port)
end

function step(self, timeout)
    -- check for new connections
    local sock = self.socket:accept()
    if sock then
        self:register(sock)
    end
    
    -- check for incoming and outgoing messages
    local rr, wr = socket.select(self.sockets, self.sockets, timeout)
    
    -- incoming messages
    for _,sock in ipairs(rr) do
        self.clients[sock]:receiveOne()
    end
    
    -- outgoing messages
    for _,sock in ipairs(wr) do
        -- it's possible something went wrong and the socket was closed and culled during
        -- the read phase
        if self.clients[sock] then
            self.clients[sock]:sendOne()
        end
    end
end

-- cleanly shut down the server. FIXME: not implemented
function stop(self)
    self:broadcast {
        method = "message";
        "Disconnected: server shutting down";
    }
    self:broadcast(false)
    self._break = true
end

function register(self, socket)
    self:message("Client connected from %s.", socket:getpeername())
    
    table.insert(self.sockets, socket)
    self.clients[socket] = new "ClientWorker" {
        socket = socket;
        server = self;
    }

    -- tell everyone that they've arrived
    self:broadcast {
        method = "message";
        "Connection established from %s", socket:getpeername();
    }
end

function unregister(self, client)
    self.clients[client.socket] = nil
    self.players[client.name] = nil

    for k,v in ipairs(self.sockets) do
        if v == client.socket then
            table.remove(self.sockets, k)
            break
        end
    end
    self:message("Client %s disconnected.", tostring(client))
end

function broadcast(self, msg)
    for _,client in pairs(self.clients) do
        client:send(msg)
    end
end

function loop(self, timeout)
    self._break = nil
    repeat
        self:step(timeout)
    until self._break
    self._break = nil
end

-- server message function, prefixes messages with [server]
function message(self, fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

function dispatch(self, msg, sender)
    if not msg.self then
        assert(self.api[msg.method], "no method "..tostring(msg.method).." in server API")
        self.api[msg.method](self, sender, table.unpack(msg))
    else
        msg.self[msg.method](msg.self, sender, table.unpack(msg))
    end
end

-- public API callable by clients
-- signature is (self, client, ...)
api = {}

function api:login(client, name, pass)
    if type(name) ~= "string" then
        client:disconnect("Malformed login message.")
    elseif self.pass and self.pass ~= pass then
        client:disconnect("Password incorrect.")
    elseif self.clients[name] then
        client:disconnect("Name already in use.")
    else
        client:setName(name)
        self.players[client.name] = client
        -- FIXME: register corresponding player object with game state?
    end

    -- send them the initial gamestate
    client:send {
        method = "game";
        self.game;
    }

    self:broadcast {
        method = "message";
        "%s joins the game", name;
    }
end

function api:chat(client, ...)
    self:broadcast {
        method = "chat";
        client.player.name, ...;
    }
end
