-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"

server = {}

local _sockets,_clients,_players
local _game
local _socket
local _info

function server.start(info)
	-- if these aren't set, it's a programming error
	assert(info.port and info.host and info.name, "Invalid arguments to constructor for server.Server")
	assert(not _game, "Server is already running")

    _info = info
    _sockets,_clients,_players = {},{},{}

    local err
    _socket,err = socket.bind(info.host, info.port)
    
    if not _socket then
        return nil,err
    end
    
    -- HACK HACK HACK - test code
    _game = new "Game" { name = "Test Game" }
    _game:openGame("chess")

    _socket:settimeout(0.1)
    server.log("Listening on port %d", info.port)
end

function server.step(timeout)
    -- check for new connections
    local sock = _socket:accept()
    if sock then
        server.register(sock)
    end

    -- check for incoming and outgoing messages
    local rr, wr = socket.select(_sockets, _sockets, timeout)
    
    -- incoming messages
    for _,sock in ipairs(rr) do
        _clients[sock]:receiveOne()
    end
    
    -- outgoing messages
    for _,sock in ipairs(wr) do
        -- it's possible something went wrong and the socket was closed and culled during
        -- the read phase
        if _clients[sock] then
            _clients[sock]:sendOne()
        end
    end
end

function server.game()
    return _game
end

local _break
function server.loop(timeout)
    _break = nil
    repeat
        server.step(timeout)
    until _break
    _break = nil
end

-- cleanly shut down the server.
function server.stop(reason)
    reason = reason or "server shutdown"

    -- _immediately_ send the message to each client,
    -- then close the socket
    -- FIXME

    _socket:close()
    _clients,_sockets,_players,_game,_info,_socket = nil
    _break = true
end

function server.send(msg)
    for _,client in pairs(_players) do
        client:send(msg)
    end
end

function server.register(socket)
    server.log("Client connected from %s.", socket:getpeername())

    table.insert(_sockets, socket)
    _clients[socket] = new "ClientWorker" {
        socket = socket;
        game = _game;
    }
end

function server.unregister(client)
    _clients[client.socket] = nil

    if _players[client.name] then
        client.player:disconnect()
        _players[client.name] = nil
    end

    for k,v in ipairs(_sockets) do
        if v == client.socket then
            v:close()
            table.remove(_sockets, k)
            break
        end
    end

    server.log("%s disconnected.", tostring(client))
end

-- server log function, prefixes messages with [server]
function server.log(fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

-- convenience function to broadcast a text message to all connected clients
function server.message(...)
    return server.send {
        method = "message";
        string.format(...)
    }
end

function server.dispatch(msg, sender)
    if not msg.self then
        assert(server.api[msg.method], "no method "..tostring(msg.method).." in server API")
        server.api[msg.method](sender, table.unpack(msg))
    else
        print("dispatch", msg.self, sender, sender.player)
        msg.self[msg.method](msg.self, sender.player, table.unpack(msg))
    end
end

-- public API callable by clients
-- signature is (client, ...)
server.api = {}

function server.api.login(client, name, pass, r, g, b)
    if type(name) ~= "string" then
        client:disconnect("Malformed login message.")
        return
    elseif _info.pass and _info.pass ~= pass then
        client:disconnect("Password incorrect.")
        return
    elseif _players[name] then
        client:disconnect("Name already in use.")
        return
    end

    local player = new "game.felt.Player" {
        name = name;
        r = r, g = g, b = b;
    }

    client:setName(name)
    client:setPlayer(player)
    _game:addPlayer(player)
    _players[client.name] = client

    -- send them the initial gamestate
    client:send {
        method = "game";
        _game;
    }

    server.message("%s joins the game.", name)
end

function server.api.chat(client, str)
    server.send {
        method = "chat";
        client.name, str;
    }
end
