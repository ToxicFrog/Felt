-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"

class(..., felt.Object)

id = "S" -- the server always has id "S" so that clients can refer to it
updating = false -- true during a server update step; the automatic RMI dispatcher
-- needs to be able to tell whether it's executing in a server or client ctx

local _init = __init
function __init(self, t)
	_init(self, t)
	self.events = {}
end

-- server message function, prefixes messages with [server]
function message(self, fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

-- mainloop tick function, called every frame by main
function update(self)
	if not self.socket then return end
	
	self.updating = true
	local i = 1
	local events = self.events
	
	-- TODO: collect events from network sockets
	self:tryAccept()
	
	self:collectMessages()
	
	while events[i] do
		self:dispatch(events[i])
		i = i+1
	end
	
	self.events = {}
	self.updating = false
end

function tryAccept(self)
	local sock = self.socket:accept()
	if sock then
		self:message("Connection accepted from %s", sock:getpeername())
	end
	table.insert(self.sockets, sock)
end

function collectMessages(self)
	local ready = socket.select(self.sockets, {}, 0)
	for i=1,#self.sockets do
		print(i, ready[i])
		if ready[i] then
			local buf,err = ready[i]:receive()
			print(buf, err)
			if not buf then
				-- whoops, error reading from socket (closed?)
				self:message("closing connection to %s (%s)", ready[i]:getpeername(), err)
				table.remove(self.sockets, i)
			else
				self:pushEvent { self, "message", "%s", buf }
			end
		end
	end
end

function pushEvent(self, evt)
	table.insert(self.events, evt)
end

function dispatch(self, evt)
	local obj = evt[1]
	local method = evt[2]
	
	assert(obj, "Malformed RMI: no object")
	assert(obj[method], "Malformed RMI: object "..tostring(obj).." has no method "..tostring(method)) 
	obj[method](obj, unpack(evt, 3))
end

function login(self, client, name, pass)
	print(self, client, name, pass)
	self:message("Player connecting: %s", name)
	if self.pass ~= pass then
		self:message("Rejecting %s due to bad password.", name)
		return client:disconnect("Invalid password.")
	end

	if self.players[name] then
		self:message("Rejecting %s due to name collision.", name)
		return client:disconnect("A player with the name '"..tostring(name).."' is already present in game.")
	end
	
	self:message("Handshake with %s completed.", name)
	
	return client:setGame(self.game)
end

function broadcast(self, object, method, ...)
	--[[
	for k,v in pairs(self.players) do
		self.players:
		FIXME
		]]
	object[method](object, ...)
end

function addPlayer(self, client, name, colour, pass)
	self.players[name] = client
	self.game:addPlayer(name, colour)
	
	-- tell the player about the game state
	-- if it's a local client, this just passes a reference to the gamestate
	-- object
	-- if it's a remote client, it packs the gamestate into a string (as though
	-- saving it) and shoves it down the pipe
	client:setGame(self.game)
	client:setPlayer(self.game.players[name])
end

-- public API to the server subsystem

function start(self, port, pass, file)
	self.players = {}
	self.sockets = {}
	
	local err
	self.socket,err = socket.bind("*", port)
	
	if not self.socket then
		ui.error("Unable to start server (networking error): "..err)
		return false
	end
	
	self.socket:settimeout(0)
	
	if file then
		-- load game from file - FIXME
		error("not implemented")
		self.game = deserialize_file(file)
	else
		self.game = new "felt.Game" {}
	end
	
	self:message("server listening on port %d", port)
	
	return true
end

function stop(self, reason)
	error("not implemented")
end
