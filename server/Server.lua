-- A server is mainly an event collector and dispatcher. Fundamentally, it
-- consists of the following:
-- - a game state
-- - an event queue, which is filled (in a nonspecific manner) with events
--   generated by the clients
-- - an update method which is called often and empties the queue, dispatching
--   the events stored therein
-- - a means by which RMIs can be propagated to the clients
--   - this implies a set of clients and a broadcast API
require "socket"

local super = class(..., felt.Object)

id = "S" -- the server always has id "S" so that clients can refer to it

function __init(self, t)
	super.__init(self, t)
	self.events = {}
	self.players = {}
	
	assert(self.game, "No game state passed to server at initialization")
	
	self.socket = assert(socket.
	--self.game:putObject(self) -- store the reference to the server in the game state
end

-- server message function, prefixes messages with [server]
function message(self, fmt, ...)
	return ui.message("[server] "..fmt, ...)
end

-- mainloop tick function, called every frame by main
function update(self)
	local i = 1
	local events = self.events
	
	-- collect events from network sockets
	
	while events[i] do
		self:dispatch(events[i])
		i = i+1
	end
	
	self.events = {}
end

function pushEvent(self, evt)
	table.insert(self.events, evt)
end

function dispatch(self, evt)
	local obj = evt[1]
	local method = evt[2]
	
	assert(obj[method], "Malformed RMI: object "..tostring(obj).." has no method "..tostring(method)) 
	obj[method](obj, unpack(evt, 3))
end

function login(self, client, name, pass)
	print(self, client, name, pass)
	self:message("Player connecting: %s", name)
	if self.pass ~= pass then
		self:message("Rejecting %s due to bad password.", name)
		return client:disconnect("Invalid password.")
	end

	if self.players[name] then
		self:message("Rejecting %s due to name collision.", name)
		return client:disconnect("A player with the name '"..tostring(name).."' is already present in game.")
	end
	
	self:message("Handshake with %s completed.", name)
	
	return client:setGame(self.game)
end

function broadcast(self, object, method, ...)
	--[[
	for k,v in pairs(self.players) do
		self.players:
		FIXME
		]]
	object[method](object, ...)
end

function addPlayer(self, client, name, colour, pass)
	self.players[name] = client
	self.game:addPlayer(name, colour)
	
	-- tell the player about the game state
	-- if it's a local client, this just passes a reference to the gamestate
	-- object
	-- if it's a remote client, it packs the gamestate into a string (as though
	-- saving it) and shoves it down the pipe
	client:setGame(self.game)
	client:setPlayer(self.game.players[name])
end
